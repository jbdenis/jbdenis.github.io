<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf8">
  <meta name="creation" content=" 2021_01_16@11:07 ">
  <meta http-equiv="charset" content="utf8">
  <title>uie.pm</title>
</head>
<body>
<h2>
MODULE uie
</h2>
<p><pre>
</pre></p>
<par>
To get the content of the module <a href="uie.pm">uie.pm</a>
</par>
<p>
&nbsp;
&nbsp;&nbsp;
A total of 49 subroutines was detected:
&nbsp;
</p>
<table border="3">
  <tbody>
    <tr>
    </tr>
      <td><strong>add</strong></td>
      <td>
<a href="#sub add8err {">
add8err
</a>
      </td>
    <tr>
    </tr>
      <td><strong>answer</strong></td>
      <td>
<a href="#sub get8answer {">
get8answer
</a>
      </td>
    <tr>
    </tr>
      <td><strong>ask</strong></td>
      <td>
<a href="#sub ask8question {">
ask8question
</a>
      </td>
    <tr>
    </tr>
      <td><strong>belong</strong></td>
      <td>
<a href="#sub belong9 {">
belong9
</a>
      </td>
    <tr>
    </tr>
      <td><strong>block</strong></td>
      <td>
<a href="#sub read8block {">
read8block
</a>
      </td>
    <tr>
    </tr>
      <td><strong>check</strong></td>
      <td>
<a href="#sub check8err {">
check8err
</a>
      </td>
      <td>
<a href="#sub check8narray {">
check8narray
</a>
      </td>
      <td>
<a href="#sub check8ref {">
check8ref
</a>
      </td>
    <tr>
    </tr>
      <td><strong>clean</strong></td>
      <td>
<a href="#sub clean8string {">
clean8string
</a>
      </td>
    <tr>
    </tr>
      <td><strong>compare</strong></td>
      <td>
<a href="#sub compare8set {">
compare8set
</a>
      </td>
    <tr>
    </tr>
      <td><strong>conca</strong></td>
      <td>
<a href="#sub conca8err { ">
conca8err
</a>
      </td>
    <tr>
    </tr>
      <td><strong>copy</strong></td>
      <td>
<a href="#sub copy8structure {">
copy8structure
</a>
      </td>
    <tr>
    </tr>
      <td><strong>csv</strong></td>
      <td>
<a href="#sub dim4csv {">
dim4csv
</a>
      </td>
      <td>
<a href="#sub line4csv {">
line4csv
</a>
      </td>
      <td>
<a href="#sub read8csv {">
read8csv
</a>
      </td>
      <td>
<a href="#sub write8csv {">
write8csv
</a>
      </td>
    <tr>
    </tr>
      <td><strong>dim</strong></td>
      <td>
<a href="#sub dim4csv {">
dim4csv
</a>
      </td>
    <tr>
    </tr>
      <td><strong>dir</strong></td>
      <td>
<a href="#sub find8dir {">
find8dir
</a>
      </td>
    <tr>
    </tr>
      <td><strong>eml</strong></td>
      <td>
<a href="#sub make8eml {">
make8eml
</a>
      </td>
    <tr>
    </tr>
      <td><strong>err</strong></td>
      <td>
<a href="#sub add8err {">
add8err
</a>
      </td>
      <td>
<a href="#sub check8err {">
check8err
</a>
      </td>
      <td>
<a href="#sub conca8err { ">
conca8err
</a>
      </td>
      <td>
<a href="#sub err9 {">
err9
</a>
      </td>
      <td>
<a href="#sub print8err {">
print8err
</a>
      </td>
    <tr>
    </tr>
      <td><strong>extract</strong></td>
      <td>
<a href="#sub extract8format {">
extract8format
</a>
      </td>
      <td>
<a href="#sub extract8name {">
extract8name
</a>
      </td>
      <td>
<a href="#sub extract8string {">
extract8string
</a>
      </td>
    <tr>
    </tr>
      <td><strong>file</strong></td>
      <td>
<a href="#sub file9 {">
file9
</a>
      </td>
      <td>
<a href="#sub join8file {">
join8file
</a>
      </td>
      <td>
<a href="#sub name8file {">
name8file
</a>
      </td>
      <td>
<a href="#sub save8file {">
save8file
</a>
      </td>
    <tr>
    </tr>
      <td><strong>find</strong></td>
      <td>
<a href="#sub find8dir {">
find8dir
</a>
      </td>
    <tr>
    </tr>
      <td><strong>format</strong></td>
      <td>
<a href="#sub extract8format {">
extract8format
</a>
      </td>
    <tr>
    </tr>
      <td><strong>get</strong></td>
      <td>
<a href="#sub get8answer {">
get8answer
</a>
      </td>
    <tr>
    </tr>
      <td><strong>hash</strong></td>
      <td>
<a href="#sub join8hash {">
join8hash
</a>
      </td>
    <tr>
    </tr>
      <td><strong>hmat</strong></td>
      <td>
<a href="#sub print8hmat {">
print8hmat
</a>
      </td>
    <tr>
    </tr>
      <td><strong>html</strong></td>
      <td>
<a href="#sub spec2html {">
spec2html
</a>
      </td>
      <td>
<a href="#sub text2html {">
text2html
</a>
      </td>
    <tr>
    </tr>
      <td><strong>join</strong></td>
      <td>
<a href="#sub join8file {">
join8file
</a>
      </td>
      <td>
<a href="#sub join8hash {">
join8hash
</a>
      </td>
    <tr>
    </tr>
      <td><strong>line</strong></td>
      <td>
<a href="#sub line4csv {">
line4csv
</a>
      </td>
      <td>
<a href="#sub read8line {">
read8line
</a>
      </td>
    <tr>
    </tr>
      <td><strong>make</strong></td>
      <td>
<a href="#sub make8eml {">
make8eml
</a>
      </td>
      <td>
<a href="#sub make8name {">
make8name
</a>
      </td>
    <tr>
    </tr>
      <td><strong>name</strong></td>
      <td>
<a href="#sub extract8name {">
extract8name
</a>
      </td>
      <td>
<a href="#sub make8name {">
make8name
</a>
      </td>
      <td>
<a href="#sub name8file {">
name8file
</a>
      </td>
    <tr>
    </tr>
      <td><strong>narray</strong></td>
      <td>
<a href="#sub check8narray {">
check8narray
</a>
      </td>
    <tr>
    </tr>
      <td><strong>panneau</strong></td>
      <td>
<a href="#sub print8panneau {">
print8panneau
</a>
      </td>
    <tr>
    </tr>
      <td><strong>print</strong></td>
      <td>
<a href="#sub print8err {">
print8err
</a>
      </td>
      <td>
<a href="#sub print8hmat {">
print8hmat
</a>
      </td>
      <td>
<a href="#sub print8panneau {">
print8panneau
</a>
      </td>
      <td>
<a href="#sub print8structure {">
print8structure
</a>
      </td>
    <tr>
    </tr>
      <td><strong>question</strong></td>
      <td>
<a href="#sub ask8question {">
ask8question
</a>
      </td>
    <tr>
    </tr>
      <td><strong>read</strong></td>
      <td>
<a href="#sub read8block {">
read8block
</a>
      </td>
      <td>
<a href="#sub read8csv {">
read8csv
</a>
      </td>
      <td>
<a href="#sub read8line {">
read8line
</a>
      </td>
      <td>
<a href="#sub read8structure {">
read8structure
</a>
      </td>
    <tr>
    </tr>
      <td><strong>ref</strong></td>
      <td>
<a href="#sub check8ref {">
check8ref
</a>
      </td>
    <tr>
    </tr>
      <td><strong>replace</strong></td>
      <td>
<a href="#sub replace8string {">
replace8string
</a>
      </td>
    <tr>
    </tr>
      <td><strong>save</strong></td>
      <td>
<a href="#sub save8file {">
save8file
</a>
      </td>
    <tr>
    </tr>
      <td><strong>script</strong></td>
      <td>
<a href="#sub trace8script {">
trace8script
</a>
      </td>
    <tr>
    </tr>
      <td><strong>set</strong></td>
      <td>
<a href="#sub compare8set {">
compare8set
</a>
      </td>
    <tr>
    </tr>
      <td><strong>spec</strong></td>
      <td>
<a href="#sub spec2html {">
spec2html
</a>
      </td>
    <tr>
    </tr>
      <td><strong>split</strong></td>
      <td>
<a href="#sub split8string {">
split8string
</a>
      </td>
    <tr>
    </tr>
      <td><strong>string</strong></td>
      <td>
<a href="#sub clean8string {">
clean8string
</a>
      </td>
      <td>
<a href="#sub extract8string {">
extract8string
</a>
      </td>
      <td>
<a href="#sub replace8string {">
replace8string
</a>
      </td>
      <td>
<a href="#sub split8string {">
split8string
</a>
      </td>
    <tr>
    </tr>
      <td><strong>structure</strong></td>
      <td>
<a href="#sub copy8structure {">
copy8structure
</a>
      </td>
      <td>
<a href="#sub print8structure {">
print8structure
</a>
      </td>
      <td>
<a href="#sub read8structure {">
read8structure
</a>
      </td>
      <td>
<a href="#sub write8structure {">
write8structure
</a>
      </td>
    <tr>
    </tr>
      <td><strong>text</strong></td>
      <td>
<a href="#sub text2html {">
text2html
</a>
      </td>
    <tr>
    </tr>
      <td><strong>trace</strong></td>
      <td>
<a href="#sub trace8script {">
trace8script
</a>
      </td>
    <tr>
    </tr>
      <td><strong>write</strong></td>
      <td>
<a href="#sub write8csv {">
write8csv
</a>
      </td>
      <td>
<a href="#sub write8structure {">
write8structure
</a>
      </td>
    <tr>
    </tr>
      <td><strong>z...</strong></td>
      <td>
<a href="#sub argu {">
argu
</a>
      </td>
      <td>
<a href="#sub juste {">
juste
</a>
      </td>
      <td>
<a href="#sub justn {">
justn
</a>
      </td>
      <td>
<a href="#sub la {">
la
</a>
      </td>
      <td>
<a href="#sub now {">
now
</a>
      </td>
      <td>
<a href="#sub numerical {">
numerical
</a>
      </td>
      <td>
<a href="#sub ordre {">
ordre
</a>
      </td>
      <td>
<a href="#sub pause {">
pause
</a>
      </td>
      <td>
<a href="#sub seqn {">
seqn
</a>
      </td>
  </tbody>
</table>
<ol>
<li>
<a href="#sub add8err {">
sub add8err {                 (creating and/or adding error messages)
</a>
</li>
<li>
<a href="#sub argu {">
sub argu {                    (decoding and checking arguments given through hashes)
</a>
</li>
<li>
<a href="#sub ask8question {">
sub ask8question {            (asking one question on the screen without check)
</a>
</li>
<li>
<a href="#sub belong9 {">
sub belong9 {                 (scalar belongs to array?)
</a>
</li>
<li>
<a href="#sub check8err {">
sub check8err {               (check for an error object)
</a>
</li>
<li>
<a href="#sub check8narray {">
sub check8narray {            (check a structure of nested arrays)
</a>
</li>
<li>
<a href="#sub check8ref {">
sub check8ref {               (checking references)
</a>
</li>
<li>
<a href="#sub clean8string {">
sub clean8string {            (removes spacing and more into a string)
</a>
</li>
<li>
<a href="#sub compare8set {">
sub compare8set {             (compare the elements of two arrays)
</a>
</li>
<li>
<a href="#sub conca8err { ">
sub conca8err {               (concatanating two error objects)
</a>
</li>
<li>
<a href="#sub copy8structure {">
sub copy8structure {          (copy a hierarquical structure of references)
</a>
</li>
<li>
<a href="#sub dim4csv {">
sub dim4csv {                 (returns the dimensions of a csv table)
</a>
</li>
<li>
<a href="#sub err9 {">
sub err9 {                    (detecting an error object)
</a>
</li>
<li>
<a href="#sub extract8format {">
sub extract8format {          
</a>
</li>
<li>
<a href="#sub extract8name {">
sub extract8name {            (extract a name from an initial name)
</a>
</li>
<li>
<a href="#sub extract8string {">
sub extract8string {          (extracting substrings from a string)
</a>
</li>
<li>
<a href="#sub file9 {">
sub file9 {                   (give the type of a name file)
</a>
</li>
<li>
<a href="#sub find8dir {">
sub find8dir {                (find directories or files)
</a>
</li>
<li>
<a href="#sub get8answer {">
sub get8answer {              (asking a series of questions from the terminal)
</a>
</li>
<li>
<a href="#sub join8file {">
sub join8file {               (make a file concatenating several files)
</a>
</li>
<li>
<a href="#sub join8hash {">
sub join8hash {               (concatening a hash)
</a>
</li>
<li>
<a href="#sub juste {">
sub juste {                   (justifying a string)
</a>
</li>
<li>
<a href="#sub justn {">
sub justn {                   (justifying a number)
</a>
</li>
<li>
<a href="#sub la {">
sub la {                      (short call to 'print8structure' and 'pause')
</a>
</li>
<li>
<a href="#sub line4csv {">
sub line4csv {                (returns one line of a csv table)
</a>
</li>
<li>
<a href="#sub make8eml {">
sub make8eml {                (builds an electronic message for 'sendmail')
</a>
</li>
<li>
<a href="#sub make8name {">
sub make8name {               (build a series of names from names and sequences)
</a>
</li>
<li>
<a href="#sub name8file {">
sub name8file {               (build a name(s) for a file from a previous one)
</a>
</li>
<li>
<a href="#sub now {">
sub now {                     (present moment (or any))
</a>
</li>
<li>
<a href="#sub numerical {">
sub numerical {               (keyboard interpretation of numerical values)
</a>
</li>
<li>
<a href="#sub ordre {">
sub ordre {                   (find a permutation reordering the element of an array)
</a>
</li>
<li>
<a href="#sub pause {">
sub pause {                   (pausing to see and get answer)
</a>
</li>
<li>
<a href="#sub print8err {">
sub print8err {               (printing an error object)
</a>
</li>
<li>
<a href="#sub print8hmat {">
sub print8hmat {              (print (and check) a hash matrix)
</a>
</li>
<li>
<a href="#sub print8panneau {">
sub print8panneau {           (printing a pannel)
</a>
</li>
<li>
<a href="#sub print8structure {">
sub print8structure {         (printing a hierarquical structure of references)
</a>
</li>
<li>
<a href="#sub read8block {">
sub read8block {              (reading a block from a text file)
</a>
</li>
<li>
<a href="#sub read8csv {">
sub read8csv {                (reading a CSV file)
</a>
</li>
<li>
<a href="#sub read8line {">
sub read8line {               (reading lines from a text file)
</a>
</li>
<li>
<a href="#sub read8structure {">
sub read8structure {          (read a structure previoulsy stored in a file)
</a>
</li>
<li>
<a href="#sub replace8string {">
sub replace8string {          (replaces keywords into a string)
</a>
</li>
<li>
<a href="#sub save8file {">
sub save8file {               (save/throw away a file)
</a>
</li>
<li>
<a href="#sub seqn {">
sub seqn {                    
</a>
</li>
<li>
<a href="#sub spec2html {">
sub spec2html {               (replace special characters with html (or reduced) coding)
</a>
</li>
<li>
<a href="#sub split8string {">
sub split8string {            (splitting a string in different ways)
</a>
</li>
<li>
<a href="#sub text2html {">
sub text2html {               (transforms a text into an html version)
</a>
</li>
<li>
<a href="#sub trace8script {">
sub trace8script {            (displays some info at the start/end of a script)
</a>
</li>
<li>
<a href="#sub write8csv {">
sub write8csv {               (writing a CSV file)
</a>
</li>
<li>
<a href="#sub write8structure {">
sub write8structure {         (write a structure in a file for future use)
</a>
</li>
</ol>
<h2>
General Presentation of uie.pm
</h2>
<p><pre>
#
# 'uie' are the three vocals of the French word 'UtIlEs',
#       to remind the basic aim of the proposed subroutines.
#
# The module comprises a series of subroutines that I found of
# use to have at hand. Surely, most of them already exist
# somewhere else in a more efficient code... but it was a 
# good exercise for me.
#
# Except for 'argu', the use of arguments is somehow standardized: 
#         (i) only character chains and references
#             are used, 
#         (ii) they are given as a hash of imposed
#              keys of three characters (as 'uie'),
#         (iii) if possible, sensible default values are
#               provided,
#         (iv) as far as possible, a check is done about
#              the values which are proposed (done by
#              subroutine 'argu').
#
# Reporting errors is a major concern of programmation
# with nested calls of routines. To help a general
# strategy has been attempted with the help of an
# error object. It is a reference
# to an array whose first component contains
# the value of the constant '$uie::err_ide'; the other components
# are error messages cumulated within the nested calls.
#
# Some errors are fatal (as those raised by 'argu') but 
# much better to trace the successive calls until the
# calling script.
#
# To do so, a subroutine returns some values or
# an error object in case of error. This error
# can comprise several elementary errors.
#
# When a subroutine calls another one which returns
# an error object, it can be printed and the process
# can be stopped, but better to add a signature about
# the call and returns an error.
#
# This can be implemented with the following 
# subroutines:
# 'err9'      To detect if a scalar is a reference to an error object.
# 'add8err'   To add an error message to an error object,
#             possibly creating it.  It allows to
#             compose a multiple error within a
#             given subroutine.
# 'conca8err' To concatenate an additional error a
#             pre-existing error object, possibly 
#             creating it. Typically adding the
#             signature in a subroutine to which
#             an error is returned by a called
#             subroutine.
# 'print8err' To print the content of an error object
#             putting in light the different levels.
# 'check8err' To simultaneously call a subroutine and
#             checks its result.
#
# But the same problem arises when a script is called
# by another script, possibly with more than a level.
# To allow tracing the script calls with more or less
# details displayed on the screen, 'trace8script' has been
# devised.
#
</pre></p>
<h2>
<a name="sub add8err {"></a>
1 sub add8err {
</h2>
<p><pre>
    #
    # title : creating and/or adding error messages
    #
    # aim: adding, possibly for the first time in that
    #      case it is also a creation, some error messages
    #      to an error object (cumulating errors detected
    #      within the same subroutine). See also &conca8err      
    #
    # output: the increased error object
    #
# arguments
my $hrsub = {err => [undef,'ac',"Error object, give a string if it is a creation"],
             nsu => [undef,'c',"Identification string,",
                               "usually the name of the calling subroutine"],
             erm => [undef,'a',"The error message"]
            };
</pre></p>
<h2>
<a name="sub argu {"></a>
2 sub argu {
</h2>
<p><pre>
    #
    # title : decoding and checking arguments given through hashes
    #
    # aim : from the hash proposed by the user
    #           and the hash defining the arguments 
    #           necessary for the subroutine,
    #       checks the validity of the user proposal and
    #       returns the completed hash. The arguments
    #       are scalars, 
    #       All keys of the proposed hash (@argu) must be described
    #                into the hash referenced by $rhsub.
    #
    # input : ($sub,$rhsub,@argu)
    #         $sub is the name of the concerned subroutine
    #         $rhsub is the hash defining the arguments
    #         necessary to '$sub' by means of a reference
    #         to a small array where:
    #           [0] is the default value (undef when there is not)
    #           [1] is the type of the argument:
    #                undef for no check.
    #                'u' for 'undef' 
    #                'h' for a reference to a hash
    #                'a' for a reference to an array
    #                's' for a reference to a scalar
    #                'r' for a reference
    #                'n' for a numerical value
    #                'c' for a chain of characters
    #                or a combination of the above
    #                   when there is more than one 
    #                   possibility e.g. 'sh' for a
    #                   reference either to a scalar
    #                   or a hash
    #           [2..] the description of the argument
    #                 to be used as an help; may not exist.
    # Notice that 'undef' cannot be a default value since such
    #        a value for [0]  means that the argument must 
    #        be provided by the call.
    #        Nevertheless, it is an acceptable value when [1] 
    #        comprises 'u'.
    #
    # Be aware that quite not understandable messages can be the 
    # consequence that a hash or an array be proposed instead of a
    # reference... since values are interpreted as a hash when the
    # total number is even.
    #
    #         @arg is the array proposed by the user to be decoded
    #              or when it comprises only one pertinent element
    #                 some help is provided about the arguments
    #                 of the subroutine. More precisely when 'HELP' the
    #                 description of all arguments is displayed,
    #                 when 'help' the list of arguments is displayed,
    #                 when an argument name, the description of it.
    #
    # output: reference to the completed hash
    #         or 1 when help is asked for.
    #
</pre></p>
<h2>
<a name="sub ask8question {"></a>
3 sub ask8question {
</h2>
<p><pre>
    #
    # title : asking one question on the screen without check
    #
    # aim: ask a question to the screen and get the answer
    #      given by means of the keyboard.
    #
    # output: the proposed answer by the user
    #             without any checking
    #
    # 
# arguments
my $hrsub = {que  =>[undef,"c","The question to be raised"],
             typ  =>[    0,"n","Must the input numerically transformed?"],
             fmt  =>[{avant=>"=> ",apres=>" : ",long=>60,just=>"r"},"h",
                     "The way the question be justified\n  ('{}' for no justification)"]
            };
</pre></p>
<h2>
<a name="sub belong9 {"></a>
4 sub belong9 {
</h2>
<p><pre>
    #
    # title : scalar belongs to array?
    #
    # aim : test if a scalar belongs to a given array
    #
    # output: an array [and NOT a reference to an array] of the element numbers of occurrence.
    #         so () means not found
    #            (0,7) found in the first and eigth elements
    #
    # arguments
    my $hrsub = {sca =>[undef,"s","The element to be checked."],
                 arr =>[undef,"a","The array where are stored the possible elements."],
                 low =>[0,    "n","Must the comparison be made after lower casing?"],
                 com =>[["=~ /^","\$/"],"a","A reference to an array of two elements",
                                           "to be used for the comparison with the",
                                           "included operator. Default is the matching",
                                           "operator and the strict equality pattern;",
                                           "it is equivalent to ['eq ','']",
                                           "Some care must be taken with the '\', for",
                                           "instance to remove spaces at the end, one",
                                           'must enter: ["=~ /^\\s*","\\s*\$/"]'],
                 sen =>[0,    "n","Must the comparison made 'array[#] =~ /...scalar.../'",
                                  "or the opposite which is the default behavior",
                                  "i.e. 'scalar =~ /...array[#].../'"]
                };
</pre></p>
<h2>
<a name="sub check8err {"></a>
5 sub check8err {
</h2>
<p><pre>
    #
    # title : check for an error object
    #
    # aim: when an error object, prints it and
    #      possibly die.
    #
    # output: the checked object if it is not an error
    #
# arguments
my $hrsub = {obj => [undef,'uhasrnc',"Possible error object"],
             wha => [    0,'n',"When '0' dies in case of error",
                               "When '1' returns the error message"],
             sig => [   "","c","A signature to add when printing the error"]
            };
</pre></p>
<h2>
<a name="sub check8narray {"></a>
6 sub check8narray {
</h2>
<p><pre>
    #
    # title : check a structure of nested arrays
    #
    # aim : first an ancillary subroutine for &phoges::pi9
    #       but can have a more general use
    #         
    #
    # a nested array can be a simple chain,
    #                or a reference to an array of chains,
    #                or a reference to an  array of chains and reference to arrays,
    #                and so on
    #                (each referred array can contain chains|undefs|references to array)
    #        
    # for instance
    #   level number : name : content
    #              0 : x0   = "c"
    #              1 : x1   = ["c1","c2","",["d1","d2"]]
    #              2 : x2   = [["c11","c12"],[],undef,[""],["c21"]]
    #              3 : x3   = [[["c111","c112"],["c121",""],[""],[]],
    #                          [["c211","c212"],["c221","c222","c223"]],
    #                          [[],undef,undef,[]]
    #                         ]
    #        and so on...
    #
    # remark :  recursivity is used
    #
    #
    # output : a reference to a hash with the following {keys} values:
    #          about non array components in the structure
    #             {cto} : total number
    #             {cun} : number of undef
    #             {cvo} : number of ""
    #             {cfi} : number of filled
    #             {cde} : array storing the depth of each final component
    #          about reference to array components
    #             {ale} : maximum number of levels (0 for a single chain,...)
    #                     --- be aware that '[]' is considered with 0 level ---
    #             {ato} : total number 
    #             {avo} : total number of []
    #             {afi} : total number of filled arrays
    #             {are} : [0/1] is the narray regular (having all values at 
    #                     the same depth
    #          about values
    #             {vac} : a reference to an array where all placed, including
    #                     undef values, all non array components in a single
    #                     list, for instance x1 gives  ["c1","c2","","d1","d2"].
    #             {vcc} : same as {vac} but where the values are joined in a
    #                     single chain with a separator given by $sep->[0].
    #                     For instance, if $sep->[0] = " / ", x1 gives
    #                     "c1 / c2 /  / d1 / d2".
    #             {va1} : a reference to an array where all placed, including
    #                     undef values, all FIRST non array components in a single
    #                     list, for instance x1 gives  ["c1","","d1"].
    #             {vc1} : same as {va1} but where the values are joined in a
    #                     single chain with a separator given by $sep->[0].
    #                     For instance, if $sep->[0] = " / ", x1 gives
    #                     "c1 /  / d1".
    #
    #          in case of inconsistency: a fatal error is returned
    #
    # arguments
    my $hrsub = {xxx  =>[undef,  "acu","The structure to investigate"],
		 lmx  =>[   10,  "n","The maximum value for the level number"],
		 res  =>[{cto=>0,cun=>0,cvo=>0,cfi=>0,
                          ato=>0,avo=>0,afi=>0,are=>1,ale=>0,
                          cde=>[],nre=>0,
                          vac=>[],vcc=>"",
                          va1=>[],vc1=>""},
			 "h",
                         "Initial hash to use for recursion,",
			 "progressively transformed into the output.",
			 "To the exception of {cde} which is compulsory,",
                         "only the existing keys are filled; the type of",
			 "their respective values must be consistent with",
			 "the expected output.",
                         "Possibly an error message."],
		 sep  =>[", ",  "c","Separator to use for building the",
			 "{vcc} chains."],
		 kkk  =>[  0, "n","to know the depth of the recursion"],
		 uuu  =>[  0, "n","to detect the first element within the recursion"]
                };
</pre></p>
<h2>
<a name="sub check8ref {"></a>
7 sub check8ref {
</h2>
<p><pre>
    #
    # title : checking references
    #
    # aim : check a reference and a little more
    #
    # output: 1 when the check is positive, 0 if not.
    #           When 'O' some warning indications are printed.
    #
    # For the moment, only scalar, array and hash are checked. 
    #     Giving 'check8ref' a reference to another type will
    #     be considered faultly.
    #
    # arguments
    my $hrsub = {ref =>[undef,"r","The reference to be checked"],
                 typ =>[ "sah","c","Type of the reference 'h','a','s' or a combination of them"],
                 rlo =>[ [-1,-1],"a","minimum and maximum lengths when reference to array or to hash",
                                   " ('[-1,-1]' means no check)"],
                 key =>[ [],"a","Possible key values in the referred array when reference to a hash",
                                " ('[]' means no check)"]
                };
</pre></p>
<h2>
<a name="sub clean8string {"></a>
8 sub clean8string {
</h2>
<p><pre>
    #
    # title : removes spacing and more into a string
    #
    # aim: from a reference to an array of strings
    #      returns it after some processing about spaces and
    #      comments to each of its components. Actions follow
    #      the presentation order of the arguments.
    #      Be aware that when a line is splitted due
    #         to the existence of a separator,
    #         additionnal components are introduced.
    #
    # output: a reference to an array of strings
    #
    #
# arguments
my $hrsub = {str =>[undef,"ac","The reference to an array of strings to modify"],
             sep =>[undef,"cu","Separator when some lines must be splitted",
                              "'undef' means no splitting"],
             dbl =>[    1,"n","Transforms multiple spaces into unique spaces"],
             spa =>[    3,"n","0: nothing, 1: remove starting spaces,",
                              "2: remove trailing spaces, 3: 1+2."],
             co1 =>[  "#","uc","If defined, any string starting with it is reduced to ' '"],
             co2 =>[ "##","uc","If defined, only the part of the string before it is retained"],
             nun =>[    1,"n","Must the space components be removed?"]
            };
</pre></p>
<h2>
<a name="sub compare8set {"></a>
9 sub compare8set {
</h2>
<p><pre>
    #
    # title : compare the elements of two arrays
    #
    # aim : two arrays are interpreted as two sets of
    #       strings and this subroutine performs some
    #       set operations on them
    #
    # output: a reference to an array of the element 
    #         resulting from the operation onto the 
    #         two sets.
    #
    # arguments
    my $hrsub = {se1 =>[undef,"a","Reference to the first set"],
                 se2 =>[undef,"a","Reference to the second set"],
                 ope =>[  "d","c","The operation to perform onto the two sets",
                                   "Possibilities are:",
                                   "   'i' for intersection",
                                   "   'u' for union",
                                   "   'd' for symmetric difference",
                                   "   'a' for complement of se2 in se1",
                                   "   'b' for complement of se1 in se2"],
                 rep =>[    1,"n","Must repetitions be considered (if not eliminated)."]
                };
</pre></p>
<h2>
<a name="sub conca8err { "></a>
10 sub conca8err { 
</h2>
<p><pre>
    #
    # title : concatanating two error objects
    #         (formerly 'cum8err')
    #
    # aim: to cumulate a new error with older ones
    #      coming from different subroutines.
    #      (null error are accepted). 
    #      See also &add8err      
    #
    # output: the created error object
    #
# arguments
my $hrsub = {er1 => [undef,'ac',"Initial error object"],
             er2 => [undef,'ac',"Error object to cumulate at the end"]
            };
</pre></p>
<h2>
<a name="sub copy8structure {"></a>
11 sub copy8structure {
</h2>
<p><pre>
    #
    # title : copy a hierarquical structure of references
    #
    # aim : when one wants to get an independent copy
    #        of a structure of references, a complete
    #        exploration of the structure is necessary,
    #        this is tedious and hazardous. This subroutine
    #        makes the job for you. See also '&print8structure'.
    #
    # output: the copied structure or an error message
    #         (or 1 if help was asked about the arguments)
    #
# arguments
my $hrsub = {str =>[undef,"csahu","The structure to be copied"],
             pro =>[0,"n","The depth of the copy (used for recursivity)."],
             prm =>[12,"n","The maximum depth admitted for recursivity",
                           "when attained 0 is returned"]
            };
</pre></p>
<h2>
<a name="sub dim4csv {"></a>
12 sub dim4csv {
</h2>
<p><pre>
    #
    # title : returns the dimensions of a csv table
    #
    # aim: from reference to a matrix as obtained with
    #      'read8csv', returns its dimensions.
    #
    # output: a reference to an array of length 2 with
    #         the number of lines et the number of columns
    #         '[nblig,nbcol]'.
    #
# arguments
my $hrsub = {mat  =>[undef,"h","The matrix, as returned by 'read8csv'"]
            };
</pre></p>
<h2>
<a name="sub err9 {"></a>
13 sub err9 {
</h2>
<p><pre>
    #
    # title : detecting an error object
    #
    # aim: detecting an error object if the first argument
    #      is reference to a non empty array whose first
    #      component is '$uie::err_ide'.
    #
    # output: 1 if it is, 0 otherwise.
    #
# arguments
my $hrsub = {obj  =>[undef,'uhasrnc',"Possible error object"]
            };
</pre></p>
<h2>
<a name="sub extract8format {"></a>
14 sub extract8format {
</h2>
<p><pre>
    #
    # title: decompose the different pieces of a format string
    #
    # aim: gives access to the interesting part of a format
    #        which is not as easy as it could be thought.
    #
    # format: by examples: "N<v1>.jpg"
    #                      "<win[1&-1]>.restricted.txt"
    #                      "A<a>.B<b[-1]>.C<c[1;>.<d>"
    #         It is a simple chain comprising some
    #         names enclosed by "<" and ">",
    #         themselves possibly follwed by en specification
    #         enclosed by "[" and "]".
    #         Only a specification is accepted within '<' and '>'.
    # 
    # output: a reference to a hash or an error.
    #         the hash has got two keys: 'list' and 'fort':
    #            'fort' is the initial format from which
    #                   the specifications and their square bracket
    #                   have been removed, giving for the last
    #                   example: "A<a>.B<b>.C<c>.<d>"
    #            'list' is a hash with three keys: "name", "spec" and "comb"
    #               "name" gives access to an array of the ordered names
    #               "spec" gives access to a parallel array of the
    #                      associated specifications ("" if none).
    #               "comb" the combination of both
    #                      For our last example:
    #                      {name=>["a",  "b", "c","d"],
    #                       spec=>[ "", "-1","1;", ""],
    #                       comb=>[["a",""],["b","-1"],
    #                              ["c","1;"],["d",""]]}
    #
    #
    # arguments
    my $hrsub = {fmt  =>[undef, "c","format of the series of names to create (see definition before)"]
                };
</pre></p>
<h2>
<a name="sub extract8name {"></a>
15 sub extract8name {
</h2>
<p><pre>
    #
    # title : extract a name from an initial name
    # 
    # output: a string of the new name or an error
    #
    # format: a chain of the type (1): "1&-2&2" meaning that
    #            component first, last next and second must
    #            be used in that order to compose the new name.
    #            So if the initial name is 'aa.bb.cc.dd.ee'
    #            the new name will be 'aa.dd.bb'
    #            Or a chain of the type (2): "1;-2;2" meaning
    #            that the three component must excluded so
    #            'aa.bb.cc.dd.ee' becomes 'cc.ee'.
    #          The distinction of the two types is given
    #            by the separator '&' or ';'.
    #          The two types cannot be mixed.
    #          When there is no separator, it is considered
    #            as type (1) so for '-1'
    #            'aa.bb.cc.dd.ee' becomes 'ee'.
    #          To remove only a component, just add a ';' after
    #            its number, for instance with '-1;'  
    #            'aa.bb.cc.dd.ee' becomes 'aa.bb.cc.dd.ee'.
    #          When the format is '0' this means that the new
    #            name is a copy of the initial name.
    #
    # remark: the work is done at a scalar level, to get it
    #         at a vectorial one, just use 'make8name'.
    #
    # arguments
    my $hrsub = { ina  =>[undef, "c","Initial name"],
                  fmt  =>[undef, "c","Format of the name to create (see the previous description)"],
                  sep  =>[  ".", "c","Separator to use to define the components of initial and new names"]
                };
</pre></p>
<h2>
<a name="sub extract8string {"></a>
16 sub extract8string {
</h2>
<p><pre>
    #
    # title : extracting substrings from a string
    #
    # aim: from a string of characters extracts 
    #      substrings designated by some framing.
    #
    # output: a reference to the array of the found substrings
    #         (or an error in case of error when err=0).
    #         The extracted substrings can be the framed ones
    #         (default) or their complementary ones.
    #
    # remark: Be aware that framing sequences are never returned, 
    #         whatever be the choice.
    #
    #
# arguments
my $hrsub = {str =>[undef,"c","The string to extract from"],
             enc =>[ ['[',"]"],"a","Must be of length two,",
                                 "the framing pair of tags."],
             wit =>[    1,"n","to return substrings within the",
                              "framing tags if no in between."],
             err =>[    1,"n","In case of error (framing not closed),",
                              "0: returns a string with error",
                              "1: prints the error and stops"]
            };
</pre></p>
<h2>
<a name="sub file9 {"></a>
17 sub file9 {
</h2>
<p><pre>
    #
    # title : give the type of a name file
    # 
    # output: the extension and the found file type 
    #         for instance ['jpg','picture']
    #         or ['sh','shell']
    #         or ['','none']
    #         or ['tito','unknown']...
    #         See the code for complete details
    #
    # remark: lower and upper cases are not distinguished
    #
    # future: to be extended (1) with additional standard types
    #                        (2) to encompass other components
    #
    # arguments
    my $hrsub = {fil  =>[undef, "c","File name to check"],
                 typ  =>[  "n","ch","The type to use, default: standard types"]
                };
    # standard types 
    my %types = (""    =>"none",
                 "jpg" =>"picture",
                 "jpeg"=>"picture",
                 "png" =>"picture",
                 "ogg" =>"sound",
                 "txt" =>"text",
                 "sh"  =>"shell"
                );
</pre></p>
<h2>
<a name="sub find8dir {"></a>
18 sub find8dir {
</h2>
<p><pre>
    #
    # title : find directories or files
    #
    # aim: from a starting directory returns either all
    #      subdirectories or all fill included in its
    #      ramification.
    #
    # output: a reference to an array of strings containing
    #         the result, unless an error be encontoured in
    #         that case an error message is returned (to be
    #         tested with &err9.
    #
# arguments
my $hrsub = {dir =>[".","c","The starting directory"],
             qoi =>[   1,"n","1 for searching directories,",
                            "0 for searching files"],
             frg =>[  "","c","the regular expression to filter",
                           "what must be included in the result"]
            };
</pre></p>
<h2>
<a name="sub get8answer {"></a>
19 sub get8answer {
</h2>
<p><pre>
    #
    # title : asking a series of questions from the terminal
    #
    # aim: get some answers from a series of questions
    #
    # output: reference to the hash of accepted answers. 
    #
    # Notice that questions are asked again when not correctly answered.
    #
# constants
my $skip = "ssss"; 
my $quit = "SSSS"; 
my $stop = "ZZZZ"; 
my $halting = "Type '$skip/$quit/$stop' as first four characters to quit the question/call/program";
# arguments
my $hrsub = {rpl=> [undef,"a","reference to an array.\n".
                                 "   to be printed with '&print8panneau'"],
             rqu=> [undef,"h","reference to the hash of questions to ask.\n".
                                 "keys identifies the questions and values are\n".
                                 "references to hashes of the different components\n".
                                 "of the questions, each with the following keys:\n".
                                 "  - 'ques' giving the question formula.\n".
                                 "  - 'help' giving some hints about the formula to answer\n".
                                 "           with the help of an array.\n".
                                 "  - 'chec' a reference to an array specifying the possible answers.\n".
                                 "      [0] is either 'n' for numeric, 'a' for alphabetical,\n".
                                 "                 or 'p' for perl matching and anything else for no check.\n".
                                 "              . when numeric [1..3] give respectively the \n".
                                 "                      minimum [1], maximum [2] of accepted values\n".
                                 "                      and the number of decimals of truncation [3].\n".
                                 "              . when alphabetic the list of accepted values follow.\n".
                                 "              . when perl matching [1] is any expression to be enclosed\n".
                                 "                     into slashes; for instance ^[a-z][a-z]\$ to impose\n".
                                 "                     just two lower case letters.\n".
                                 "       Be aware that when [0] is 'n', the &numerical subroutine\n".
                                 "                                          is applied to the answer.",
                                 "  - 'defa' the default valeu proposed if a simple 'Enter' key is hit"],
             ror=> [undef,"a","reference to an array of 'keys %\$rquest' in the desired asking order."],
             rfo=> [{}   ,"h","reference to a hash of references to arrays giving for each\n",
                                  "question, the way to display them on the screen just above\n",
                                  "the questionning line. Individual arrays gives the necessary\n",
                                  "argument for a call to '&juste': \$avant,\$apres,\$long,\$just",
                                  "or '[]' when no formatting is desired for this question.\n",
                                  "Also when the hash is empty no formatting is done for any question."],
             lah=>[100,"n","width of the help pannel before the question"],
             loh=>[17,"n","number of lines for the help pannel, just before questions"],
             con=>["s","hc","Value for argument 'form' of '&join8hash' used when constructing",
                                 "the progressive set of answers"]
            };
</pre></p>
<h2>
<a name="sub join8file {"></a>
20 sub join8file {
</h2>
<p><pre>
    #
    # title : make a file concatenating several files
    #
    # aim: from an array indicating a series of text files, 
    #               produces a new text file, concatenating
    #               them in its order.
    #               File names can comprise a relative
    #               path which is added to the path given
    #               by argument.
    #
    #
    # output: 1 when the concatenating file is produced 
    #         or an error message when some file is not found.
    #
    # arguments
    my $hrsub = {lfi  =>[undef,"a","Array reference of the files to be read."],
                 ofi  =>[undef,"c","Name of the file to be created."],       
                 pat  =>[   "","c","Path to add before the file names"],
                 pre  =>[    0,"n","Must the output file be preserved?",
                                   "if not a preexisting will be replaced",
                                   "if yes when preexisting raise an error"],
                 hea  =>["#\n".("#"x4).("<"x40)." ???\n#","c","A heading to add before the content of each indicated file",
                                                              " ('???' is replaced by the file name)"],
                 end  =>["#\n".("#"x4)." ??? ".(">"x40)."\n#","c","An ending to add after the content of each indicated file",
                                                              " ('???' is replaced by the file name)"]
                };
</pre></p>
<h2>
<a name="sub join8hash {"></a>
21 sub join8hash {
</h2>
<p><pre>
    #
    # title : concatening a hash
    #
    # aim: prepares an array of strings displaying in
    #      a convenient way the contents of a hash
    #
    # output: the reference to the prepared array
    #
# arguments
my $hrsub = {has =>[undef,"h","The reference to the hash to be prepared"],
             ord =>[    "k","ac","defined the order to be used.",
                                 " -'k' increasing alphabetical order of the keys",
                                 " -'K' decreasing alphabetical order of the keys",
                                 " -'v' increasing alphabetical order of the values",
                                 " -'V' decreasing alphabetical order of the values",
                                 " -'n' increasing numerical order of the values",
                                 " -'N' decreasing numerical order of the values",
                                 " - or the reference to an array of the keys",
                                 "      in the desired order"],
             fmt =>[    "s","hc","Format to use for the presentation",
                                 " -'s' standard way, that is each key between",
                                 "      parentheses before it values",
                                 " -'k' only the keys surrounded with parentheses",
                                 "           and separated with a blank",
                                 " -'v' only the values separated a blank",
                                 " - or the reference to an hash with two keys",
                                 "      ('k' and 'v') indicating respectively",
                                 "      the way to prepare keys ans values:",
                                 "      'undef' means that must not be included",
                                 "      a reference to an array of four components",
                                 "      giving (i) the length of the string to indicate",
                                 "                 to &juste,",
                                 "             (ii) the type of justification to indicate",
                                 "                 to &juste,",
                                 "             (iii) the string to introduce before and",
                                 "             (iv) the string to put after.",
                                 "      (here the same format is applied to every",
                                 "       couple key/value in the next possibility",
                                 "       they can be different)",
                                 " - or the reference to an hash having keys belonging",
                                 "      to those of '\%\$hash', when a key is not present",
                                 "      the corresponding couple is not represented.",
                                 "      The values of this hash are reference with the",
                                 "      same pattern as in the previous possibility."],                     
             sep =>[    1, "n","How to present the couples of key/value.",
                                 " - 0 in a single string",
                                 " - 1 in an array of two components, for keys and for values",
                                 " - 2 in different components of an array for each couple"]
            };
</pre></p>
<h2>
<a name="sub juste {"></a>
22 sub juste {
</h2>
<p><pre>
    #
    # title : justifying a string
    #
    # aim: justify a string
    #
    # output: the fitted string
    #
    # remark: in case of truncation, a '+' is inserted in the
    #         border leading to the loss of an additional 
    #         character.
    #
    # arguments
    my $hrsub = {cha =>[undef,"c","The chain to be justified"],
                 tri =>[    1,"n","Must ending spaces be removed?"],
                 ava =>[   "","c","Chain to introduce before"],
                 apr =>[   "","c","Chain to introduce after"],
                 lon =>[   64,"n","Length of the justified chain",
                                  " (when <= 0 no justification"],
                 jus =>[  "l","c","Type of justification can be:",
                                  "   'l' for to the left without truncation",
                                  "   'L' for to the left with    truncation",
                                  "   'c' for centering without truncation",
                                  "   'C' for centering with    truncation",
                                  "   'r' for to the right without truncation",
                                  "   'R' for to the right with    truncation",
                                  "   'n' for no justification then",
                                  "       long is not considered."],
                 ulc =>[  "n","c","Type of capitalization can be:",
                                  "   'n' nothing",
                                  "   'U' every word uppercased",
                                  "   'L' every word lowercased",
                                  "   'c' first letter of each word uppercased",
                                  "   'C' first letter of each word uppercased",
                                  "       and remaining letters lowercased"],
                 spa =>[  "n","c","Prior modifications (can comprise several",
                                  "       modif, then performed in this order;",
                                  "       then the presence of 'n' implies that",
                                  "       nothing is done)",
                                  "   'n' nothing",
                                  "   's' multiple consecutive spaces are removed"]
                };
</pre></p>
<h2>
<a name="sub justn {"></a>
23 sub justn {
</h2>
<p><pre>
    #
    # title : justifying a number
    #
    # aim: justify a number, that transforming it as a string
    #      with a precised number of decimals, a fixed number
    #      of digits. For instance 12 is turned into "0012.00"
    #      for two decimals and four digits.
    #
    # output: the fitted string
    #
    # remark: no truncation for digits, 1000000 with four digits will
    #         remain "1000000" but truncation for decimals 0.1001 with
    #         two decimals will become "0.10".
    #
# arguments
my $hrsub = {num =>[undef,"n","The number to be justified"],
             dec =>[    0,"n","Desired number of decimals.",
                              "Negative value means no modification."],
             dig =>[    3,"n","Desired number of digits",
                              "Negative value means no modification."]
            };
</pre></p>
<h2>
<a name="sub la {"></a>
24 sub la {
</h2>
<p><pre>
    #
    # title : short call to 'print8structure' and 'pause'
    #
    # aim : mainly to use when debugging.
    #        'la' is a shortcut for 'look at'.
    #
    # remarks : (1) first the object is tested to be
    #          an error object, if it is it is
    #          printed with print8err subroutine.
    #
    #           (2) the 'prm' argument of 'print8structure'
    #          is given a value of 10.
    #
    # output: 1
    #
# arguments
my $hrsub = {str =>["","csahu","The structure to be displayed"],
             mes =>["","c","The associated message to the pause call",
                           "When empty string (default) pause is not called"]
            };
</pre></p>
<h2>
<a name="sub line4csv {"></a>
25 sub line4csv {
</h2>
<p><pre>
    #
    # title : returns one line of a csv table
    #
    # aim: from reference to a matrix as obtained with
    #      'read8csv', returns a line defined by its
    #      number?
    #
    # output: a reference to a hash whose keys are
    #         the column names of the matrix and the
    #         values, those of the asked line.
    #
# arguments
my $hrsub = {mat  =>[undef,"h","The matrix, as returned by 'read8csv'"],
             lin  =>[    1, "n","The number of the line to extract.",
                                "Be Aware that the first line is number 1",
                                "not following Perl standard conventions!"]
            };
</pre></p>
<h2>
<a name="sub make8eml {"></a>
26 sub make8eml {
</h2>
<p><pre>
    #
    # title : builds an electronic message for 'sendmail'
    #
    # aim: from the different parts of a message, builds
    #      a text file supposed to satisfy the MIME format
    #      possibly comprising attached files transformed
    #      into base64 code. 
    #      Notice that the message must comprise at least
    #      one part and that they are introduced in the order
    #      of the description of the arguments. Also the
    #      list of main recipients cannot be empty.
    #
    # output: the output is stored into a file and returns 1.
    #         BUT if something wrong no creation of file and
    #         an error object is returned.
    #         
    #
    #
    # arguments
    my $hrsub = {fil =>[undef,"c","Name of the file to create or replace"],
                 sbj =>[undef,"c","Subject of the mail"],
                 tow =>[undef,"ca","The string (or reference to an array of strings)",
                                   "giving the recipients of the message"],
                 cco =>["","ca","The string (or reference to an array of strings)",
                                   "giving the recipients for information of the message;",
                                   "'' which is the default value means none of them."],
                 bcc =>["","ca","The string (or reference to an array of strings)",
                                   "giving the hidden recipients of the message",
                                   "'' which is the default value means none of them."],
                 txt =>["","ca","The string (or reference to an array of strings)",
                                   "giving the series of files to be included as plain",
                                   "text parts of the message;",
                                   "'' which is the default value means none of them."],
                 htm =>["","ca","The string (or reference to an array of strings)",
                                   "giving the series of files to be included as html",
                                   "parts of the message; they are supposed to include",
                                   "the necessary tags (which can be done with 'text2html';",
                                   "'' which is the default value means none of them."],
                 b64 =>["","ca","The string (or reference to an array of strings)",
                                   "giving the series of files to be included after encoding",
                                   "in base64 format (images, pdf,...);",
                                   "'' which is the default value means none of them."],
                 chs =>[$char_set,"c","Specification of the character set to be used in",
                                      "text and html messages"]
                };
</pre></p>
<h2>
<a name="sub make8name {"></a>
27 sub make8name {
</h2>
<p><pre>
    #
    # title : build a series of names from names and sequences
    # 
    # output: an array of the new names or an error
    #
    # format : a chain of the type "<uu>.Number.<vv>.jpg"
    #          where uu and vv are the keys of initial
    #          names. They can be:
    #            - a simple (which will be duplicated),
    #            - a reference to an array of the desired length
    #            - a sequence of the desired length defined
    #              with a hash comprising the argument of 'seqn'
    #            - the present date which will be duplicated with a
    #              hash comprising the argument of 'now' (as the
    #              produced chain can comprise some spaces, it will
    #              possibly modified by a call to &uie::spec2html
    #          names, the selection of some components
    #          can be introduced by calls to extract8name,
    #          its formats being introduced between
    #          some square brackets, for instance <uu[1&-1]>
    #           
    # 
    #
    # arguments
    my $hrsub = {ini  =>[undef, "h","series of names and sequences sufficient to build the new series of names",
			            "the keys are used to describe the construction into argument 'fmt'"],
                 fmt  =>[undef, "c","format of the series of names to create (see definition before)"],
		 len  =>[    1, "n","used when necessary and/or as a check of consistency"],
		 nor  =>[    1, "n","Must the produced names be normalized (e.g. avoiding spaces)",
			            "by a call to to uie::spec2html ?"]
                };
</pre></p>
<h2>
<a name="sub name8file {"></a>
28 sub name8file {
</h2>
<p><pre>
    #
    # title : build a name(s) for a file from a previous one
    #         adding some components.
    # 
    # output: the new name(s) or an error
    #
    # remark: self-incrementation is included,
    #         in that case the output is not a chain
    #         but a reference to an array of chains
    #
    # arguments
    my $hrsub = {ina  =>[undef, "c","an initial name"],
                 wha  =>[  "C", "ca","When 'c' the string to introduce (can comprise dots).",
			             "When 'a', two cases either the first component is assessed",
			             " (1) to be a numerical value, then a numbering sequence is used",
  			             " or (2) it's not the case and it considered as a series of",
			             "components.",
                                     "When (1) must be [n] implying 1 to n",
                                     "or [n1,n2] implying n1 to n2 as string to introduce",
                                     "(see also the 'dig','bef','aft' arguments"],
                 cpt  =>[  -2,"n","where to introduce the addition",
                                  "1: at the first component",
                                  "2: at the second component and so on",
                                  "-1: at the last component",
                                  "-2: at the second last and so on"],
                 whe  =>[  "a","c","a for after the component, if not before"],
                 dig  =>[     0, "n","when 'wha' is 'a', the number of digits (see 'seqn')"],
                 bef  =>[    "", "c","when 'wha' is 'a', a chain to add before the sequence (see 'seqn')"],
                 aft  =>[    "", "c","when 'wha' is 'a', a chain to add  after the sequence (see 'seqn')"]
                };
</pre></p>
<h2>
<a name="sub now {"></a>
29 sub now {
</h2>
<p><pre>
    #
    # title : present moment (or any)
    #
    # aim : generates a string giving time and/or date
    #       according to different ways.
    #
    # output: the string
    #
    # arguments
    my $hrsub = {wha =>["dm","uc","comprises 'd' for day; 'h' for hour; 'm' for minute; 's' for second."],
                 fmt =>["red","uc","'red' to get a reduced way if not a verbose one"],
                 sep =>[["_","@",":"],"ua","The three separators to use in case of a reduced format"],
                 whe =>["now","uca","either 'now' or a reference to the equivalent of 'localtime[0,1,2,3,4,5]'"]
                };
</pre></p>
<h2>
<a name="sub numerical {"></a>
30 sub numerical {
</h2>
<p><pre>
    #
    # title : keyboard interpretation of numerical values
    #
    # aim: translate a string according to the numerical
    #      keys of a French keyboard.
    #
    # input : see the included help hash
    #          
    # output: the character string translated
    #
    #
    # arguments
    my $hrsub = {cha  =>[undef,"c","The character string to transform"],
                 tra  =>[    1,"c","Must the transformation be performed?"]
                };
</pre></p>
<h2>
<a name="sub ordre {"></a>
31 sub ordre {
</h2>
<p><pre>
    #
    # title : find a permutation reordering the element of an array
    # 
    # output: a reference to an array of same length
    #         containing a permutation (starting at 0)
    #         ordering @$rar.
    #
    # arguments
    my $hrsub = {rar  =>[undef,"a","Reference to the array to virtually sort"],
                 inc  =>[    1,"n","Must the sorting be increasing?"],
                 num  =>[    0,"n","Must the comparison be numerical?"]
                };
</pre></p>
<h2>
<a name="sub pause {"></a>
32 sub pause {
</h2>
<p><pre>
    #
    # title : pausing to see and get answer
    #
    # aim : generates a pause within a program run
    #           to see some results giving the possibility
    #           either to continue or to stop the program.
    #         Another use is to get a string answer.
    #
    # output: the resulting answer when the program is not
    #           stopped.
    #
    # arguments
    my $hrsub = {sto =>["q","c","Answer to exit the program. The chain is lowercased for the test."],
                 mes =>["" ,"c","When not the empty string, a message to add."],
                 con =>["" ,"c","Answer to continue the program (also lowercased).",
                                "When '' (default) this option is not considered,",
                                "if not: takes the priority over argument 'sto'."]
                };
</pre></p>
<h2>
<a name="sub print8err {"></a>
33 sub print8err {
</h2>
<p><pre>
    #
    # title : printing an error object
    #
    # aim: prints the first argument to be
    #      supposed an error object when it is
    #      not the case, nothing is printed.
    #
    # output: 1
    #
# arguments
    my $hrsub = {err => [undef,'ac',"Error object to print"],
		 whe => ["",'c',"Where to print",
                                "'': to the screen",
                                "'>toto.txt': in file 'toto.txt' to be created", 
                                "'>>toto.txt': in file 'toto.txt' appending it",
                                "(Be careful: the file must not be open before the call!)"] 
                };
</pre></p>
<h2>
<a name="sub print8hmat {"></a>
34 sub print8hmat {
</h2>
<p><pre>
    #
    # title : print (and check) a hash matrix
    #
    # aim : print what is called a hash matrix, that is
    #        a reference to a hash whose keys are associated
    #        to columns of a matrix and values are references
    #        to arrays providing the values of each columns.
    #        The lengths of the columns must be identical.
    #
    #       Possibly a special key '$uie::ORD' gives the order
    #        of the columns with an array containing the keys.
    #        When it exists, it is used.
    #
    #       In case of inconsistency '@$uie::sei' is completed
    #        with an appropriate message and the subroutines
    #        returns 0.
    #
    # output: 1 (or 0 in case of inconsistency).
    #
# arguments
my $hrsub = {
             hma =>[undef,"h","The structure to be printed"],
             wid =>[   10,"n","Width to give to each column"]
            };
</pre></p>
<h2>
<a name="sub print8panneau {"></a>
35 sub print8panneau {
</h2>
<p><pre>
    #
    # title : printing a pannel
    #
    # aim: display a pannel on the terminal
    #
    # remark: The length of '$tfra' indicates the total width of
    #         the pannel, too long line will be shortened. It must
    #         be equal to the length of '$bfra'.
    #         If '$tfra' is not defined '$bfra' is used instead,
    #         if the latter is not defined, 'uie::width' is used.
    #
    # output: 1
    #
# arguments
my $hrsub = {rpa =>[undef,  "a","Reference to an array of references to strings",
                                "  (each associated to a line of the pannel)",
                                "  (of course can be '[]' for an empty pannel"],
             tfr =>["*"x80, "cu"," line to be added before the pannel",
                                "    when 'undef' no line is added.",
                                "    and the constant 'uie::width' is used",
                                "    to define the width of the pannel."],
             tvo =>[1,      "n"," number of empty lines after the added line"],
             lfr =>["* ",   "c"," string to be added before each line"],
             rfr =>[" *",   "c"," string to be included to finish each line"],
             bvo =>[1,      "n"," number of empty lines before the last line"],
             bfr =>["*"x80, "cu"," line to be added at the end of the pannel",
                                "    when 'undef' no line is added."],
             jus =>[  "l","c"," type of justification for each line ('l', 'c' or 'r')",
                                "  either a scalar then the same justification",
                                "  is applied to all the lines, or a reference",
                                '  to an array having the same length than "@$rpa"',
                                "  specifying the justification for each line."],
             tco =>["green","cua"," text coloration: either 'undef' for no coloration",
                                "   or a scalar containing the color to apply to every line",
                                "   or a reference to an array containing the color".
                                "   for each line."],
             fco =>["white","cu"," frame coloration: either 'undef' for no coloration",
                                "   or a scalar containing the color to apply to the",
                                "   vertical and horizontal parts of the frame.",
                                "   Notice that you can also defined the foreground",
                                "   color and painting this way the frame for instance",
                                "   with 'on_blue blue'"]
};
</pre></p>
<h2>
<a name="sub print8structure {"></a>
36 sub print8structure {
</h2>
<p><pre>
    #
    # title : printing a hierarquical structure of references
    #
    # aim : print a structure recursively when referred hashes
    #        and array contains references. Admitted values
    #        are scalars and references to scalars, arrays and
    #        hashes. In case of a hash, the printing is done
    #        after sorting.
    #
    # output: 1
    #
# arguments
my $hrsub = {str =>[undef,"csahu","The structure to be displayed"],
             rtd =>[0,"n","Possibly a restriction for arrays and hashes",
                      "0: all components displayed",
                      "'#': only component from 1 to '#'",
                      "'-#': only component from last+1-'#' to last"],
             ind =>[{h=>"xx",a=>"++","s"=>'..',p=>"  "},"h",
                    "The way to make indentation:",
                    " h for hash reference, a for array reference",
                    " s for scalar reference and p for printing."],
             pro =>[0,"n","The depth of the display",
                          "  (used for indentation and recursivity)."],
             pri =>[0,"n","Must types of reference be added?",
                          "0 for no, 1 for starting and 2 for also ending."],
             add =>[0,"n","Must a new line added after a reference?"],
             prm =>[5,"n","The maximum depth admitted for recursivity"],
             prp =>[0,"n","Must the depth degree be printed before each line?"],
             cle =>["","c","For the hash keys (internal use)"]
            };
## To be corrected: when a value of a hash is empty array, the key appears twice! 
##                  See also the case of empty hashes.
##                  When restriction is applied on components (argument 'rtd')
##                       the mark with '. . . . ...' doesn't appear on some levels?
</pre></p>
<h2>
<a name="sub read8block {"></a>
37 sub read8block {
</h2>
<p><pre>
    #
    # title : reading a block from a text file
    #
    # aim: read a block of lines between two tags.
    #               'bbl' at the beginning of the tag to open the block
#                   (the end of this line is not considered)
#               'ebl' at the beginning of the tag to close the block
#               Ending components can be cleared out from their 
#                      starting and ending blanks characters.
#
# output: a reference to an array of references associated
#         to each line of the block, these references point
#         towards arrays of the different components of each
#         lines except when 'sep' is 'undef' where the referred
#         array is just the array of the lines.
#         possibly an error when some inconsistency found
#
# arguments
my $hrsub = {com  =>[  "#","uc","Lines beginning with it are neglected.",
                               "When 'undef' every line is considered."],
             sep  =>[ "::","cu","Separator between fields within each line.",
                               "When 'undef' no separation is performed."],
             fil  =>[undef,"c","Name of the file to be read."],
             bbl  =>["##<<","c","Tag to begin a block"],
             ebl  =>["##>>","c","Tag to   end a block"],
             bla  =>[    0,"n","Must framing blanks be removed?"],
             uni  =>[    0,"n","Must the reading be restricted to the first block?"]
            };
</pre></p>
<h2>
<a name="sub read8csv {"></a>
38 sub read8csv {
</h2>
<p><pre>
    #
    # title : reading a CSV file
    #
    # aim: read a Coma Separated Values file whose first line
    #               gives the names of the columns
    #
    # remarks: - Every line must count the same number of separators
    #            which is the number of columns minus one. Empty
    #            values are possible.
    #          - Of course empty names of columns are prohibited.
    #
    # output: a reference to a hash whose keys are the column
    #         names and the values are references associated
    #         to arrays of the columns (first line being removed).
    #         But when an inconsistence is detected, the output
    #         is an error object.
    #
# arguments
my $hrsub = {csv  =>[undef,"c","Name of the CSV file to extract",],
             sep  =>[  ";","c","Separator between fields within each line."],
             com  =>[  "#","c","Starting characters of comment lines to be ignored."]
            };
</pre></p>
<h2>
<a name="sub read8line {"></a>
39 sub read8line {
</h2>
<p><pre>
    #
    # title : reading lines from a text file
    #
    # aim: reads a text file giving back its lines after some processing
    #               (removing comments, splitting and concatinating
    #                initial lines) in a variety of way according to the
    #                arguments). True lines can be splitted or concatanated.
    #      The processing of the file follows the order of the presentation
    #                of the arguments.
    #
    # output: either (typ=1) a reference to an array. One element of it
    #                    for each meaningful line of the file;
    #             or (typ=2) a reference to a hash. Its possible keys are
    #                    indicated by arguments plus (possibly) the special
    #                    word '$STD'. Except for '$STD', the keys can be found
    #                    as first word of lines, zero, one or more time. 
    #                    These keys (including '$STD') belongs to two categories
    #                    pointing to an array or to an hash. 
    #                    When it is an array, the remaining part of the line
    #                    is the content of one element of the array.
    #                    When it is a hash, the second word of the line is
    #                    one key (so must be unique) of the hash, the remaining
    #                    part being the value.
    #                    When '$STD' is not indicated, lines not starting
    #                    with an indicated key are ignored.
    #                    Empty lines are ignored not having a key.
    #                    Second level hashes can be completed with a special key
    #                    named '$ORD' refering to an array containing the other keys in 
    #                    the order they are in the file. The length of 
    #                    this array gives the dimension of the hash, especially
    #                    when it is null.
    #         When the file is not consistent, an error is returned with
    #                    an associated message.
    #         Be aware that some care must be taken when using characters having
    #               a special meaning in regular expressions... Particularly for the
    #               argument 'con' there is no mean to introduce '++'!
    #
# arguments
my $hrsub = {fil  =>[undef,"c","Name of the file to be read."],
             stp  =>["<STOP>","c","lines starting with it indicates that the",
                                  "following lines must be ignored until",
                                  "a restart line be found",
                                  "(remaining part of this line is ignored)."],
             str  =>["<START>","c","lines starting with it cancel the effect",
                                   "of a stopping line",
                                   "(remaining part of this line is ignored)."],
             cl1  =>[{dbl=>1,spa=>3,co1=>"#",co2=>"##",nun=>1,sep=>";;"},
                          "h","The parameters to be transmitted",
                               "to 'clean8string' when applied to each",
                               "line of the file (see its documentation).",
                               "BE AWARE that if the default values are",
                               "used, you must provide the 6 values."],
             con  =>[  "plus","uc","Lines starting with it are concatenated",
                                 "to the previous one. When 'undef' no",
                                 "concatenation is attempted."],
             spl  =>[  ";;","uc","Lines are split according to it, allowing",
                                 "to introduce more than one line at once.",
                               "When 'undef' no split is attempted."],
             sep  =>[  " ","c","Separator used to determine the identifier of lines",
                               "when typ=2."],
             cl2 =>[{dbl=>1,spa=>3,co1=>undef,co2=>undef,nun=>0},
                          "h","Parameters to give",
                               "to 'clean8string' when applied to each",
                               "remaining parts of the lines",
                               "so 'sep'arator argument is not used.",
                               "Be aware that when default is not used",
                               "the 5 components must be given even if",
                               "with default values."],
             fio  =>[   "","c","Name of the file to write after pre-processing",
                               "containing only the meaningful lines. '' means",
                               "no such output."],
             typ  =>[     1,"n","The type of analysis to perform: 0 nothing, [1-2]",
                                "as explained in the general description."],
             khh  =>[ {},"h","When typ=2, reference to a hash defining the keys",
                             "pointing to second level hashes. Its keys give the",
                             "specific keys to use and its values indicate if",
                             "an 'order' key must be added. The reserved key '$STD' must",
                                "placed here to introduced lines not starting",
                                "with a specific key. Notice that if it is the",
                                "only key, all lines will be incorporated in",
                                "it!"],
             kha  =>[ [],"a","When typ=2, reference to an array defining the keys",
                             "pointing to arrays. The reserved key '$STD' must",
                                "placed here to introduced lines not starting",
                                "with a specific key. Notice that if it is the",
                                "only key, the result is similar to the one",
                                "obtained for typ=1"]
            };
</pre></p>
<h2>
<a name="sub read8structure {"></a>
40 sub read8structure {
</h2>
<p><pre>
    #
    # title : read a structure previoulsy stored in a file
    #
    # aim : reads a file produced with '&write8structure' where
    #        a structure has been stored giving back the structure.
    #
    # remarks: - no more scalar references,
    #          - no more numerical values.
    #
    # output: a reference to the structure or an error to be checked 
    #           when something went wrong
    #         
    #
# arguments
my $hrsub = {fil =>[undef,"c","Name of the file to be read"]
            };
</pre></p>
<h2>
<a name="sub replace8string {"></a>
41 sub replace8string {
</h2>
<p><pre>
    #
    # title : replaces keywords into a string
    #
    # aim: from a string (or a reference to an array of strings)
    #      returns it after replacement of keywords with
    #      given values.
    #
    #      Remark: when giving values to the two tags ('bef' and 'aft')
    #              don't forget to backslash special characters of
    #              Perl substitution!
    #              Special characters are : . * ? + [ ] ( ) { } ^ $ | \
    #              A good choice could be '<<' and '>>' 
    #                another one '#_' and '_#'.
    #
    #
    #      If the tagging doesn't exist or is not sufficient, 
    #              replacement can be made for already replaced
    #              string, producing bad results!
    #         To avoid this, the option 'let'ter make it
    #              character by character with a temporary string.
    #              When keys of the coding structure are letters
    #              this gives a good result (to be thought further)
    #
    # output: a string (or a reference to an array of strings)
    #
    #
# arguments
my $hrsub = {str =>[undef,"ca","The string (or reference to an array of strings) to modify"],
             kwd =>[undef,"h","Reference to the hash giving the replacements to performs.",
                              "Key of the hash are replaced by the associated value."],
             bef =>["","c","tag to add before the value to be replaced."],
             aft =>["","c","tag to add before the value to be replaced."],
             let =>[ 0,"n","Must replacement be made letter by letter?"]
            };
</pre></p>
<h2>
<a name="sub save8file {"></a>
42 sub save8file {
</h2>
<p><pre>
    #
    # title : save/throw away a file
    #
    # aim : prevent the consequences of a bad
    #       erasing by some precautionary duplication
    #
    # remarks : - globbing is used
    #           - saving implies changing the file name
    #             adding the moment/date as prefix
    #
    # output: 1 or an error message
    #
# arguments
my $hrsub = {fil =>[undef,"c","The file(s) to glob and save/throw away"],
             wha =>[  "s","c","What to do. The presence of some caracters",
                              "implies - in that order - the following actions:",
                              "  'p' save the file(s) into the paper basket with moment",
                              "  'r' save the file(s) into the same directory with moment",
                              "  's' save the file(s) into the same directory with date",
                              "  'd' delete the file(s)"],
             cor =>[ $cor,"c","The directory associated to the paper basket"],
             imp =>[    0,"n","Must be printed what was done?"]
            };
</pre></p>
<h2>
<a name="sub seqn {"></a>
43 sub seqn {
</h2>
<p><pre>
    #
    # title: build a numbering sequence of chains
    # 
    # aim: provide either a unique numbering nb1,..,nb2
    #              or a cross numbering 1..nb1(x)1..nb2
    #
    # output: a reference to an array of chains
    #         or possibly an error
    #
    # future: to extend to any number of crossed sequences
    #
    # arguments
    my $hrsub = {nb1  =>[     1, "un","starting number or length of the 1rst sequence"],
                 nb2  =>[ undef, "n","ending number or length of the 2d sequence"],
                 dig  =>[     0,"un","when 0 the sequence justified with the minimum digits",
                                     "when positive gives the number of digits to use",
			             "when negative no justification is done",
			      "(in case of crossed sequences, it applied to both of them)"],
		 typ  =>[     1,"un","number of sequences 1 or 2 are expected"],
                 bef  =>[    "","uc","a chain to add before the sequence"],
                 aft  =>[    "","uc","a chain to add  after the sequence"],
		 wit  =>[   "-","uc","separator between the two numberings",
			             "used only when there is a cross sequence"]
                };
</pre></p>
<h2>
<a name="sub spec2html {"></a>
44 sub spec2html {
</h2>
<p><pre>
    #
    # title : replace special characters with html (or reduced) coding
    #
    # aim: from a string (or a reference to an array of strings)
    #      returns it after replacement of , , , , ,...
    #      in standard ascii html coding or standard ascii 
    #      characters compatible for file names (as a consequence
    #      spaces are replaced with underscores.
    #
    #      Use is made of subroutine 'replace8string
    #
    # output: a string (or a reference to an array of strings)
    #
    #
# arguments
my $hrsub = {str =>[undef,"ca","The string (or reference to an array of strings) to modify"],
             htm =>[    1,"n","1: replacement made with html coding",
                              "2: (and 0 for historical reason), simplification keeping '/'",
                              "3: simplification replacing '/' with '-'"]
            };
</pre></p>
<h2>
<a name="sub split8string {"></a>
45 sub split8string {
</h2>
<p><pre>
    #
    # title : splitting a string in different ways
    #
    # aim: from a string of characters structured in some
    #      ways returns an array of individual locutions.
    #      It is basically as split except that separators
    #      can be included with framing. Typically analyzing
    #      strings like 'one two "three or four" five "6 7 8"'.
    #
    # output: a reference to the array of substrings
    #
    #
# arguments
my $hrsub = {str =>[undef,"c","The string to decompose"],
             enc =>[ ['[',"]"],"au","When of length two the framing pair of locutions. Notice",
                                 "that the opening and closing can be",
                                 "identical. When 'undef' not used."], 
             sep =>[ " ","c","Separator between locutions."],
             cle =>[{dble=>1,spac=>3,com1=>undef,com2=>undef,nunu=>1},
                         "h","Parameters to give",
                              "to 'clean8string' when applied to each",
                              "extracted sub-string"],
             err =>[    1,"n","In case of error (framing not closed),",
                              "0: returns a string with error",
                              "1: prints the error and stops"]
            };
</pre></p>
<h2>
<a name="sub text2html {"></a>
46 sub text2html {
</h2>
<p><pre>
    #
    # title : transforms a text into an html version
    #
    # aim: from a reference to an array of strings
    #      returns it after introducing some html tags.
    #      (For convenience in a paragraph context, an empty line 
    #       is considered as a paragraph separator).
    #      See also 'spec2html'
    #
    # output: a reference to an array of strings
    #
    # remarks: (1) when choosing new values for tags be aware that
    #              the special characters: . * ? + [ ] ( ) { } ^ $ | \
    #              will cause troubles!
    #          (2) when some html formatting is not available
    #              there is no harm in introducing it by hand.
    #              For instances :
    #                   <strong> What to remember: </strong>
    #                   <ol><li>Premier</li><li>Second</li></ol>
    #
# arguments
my $hrsub = {str =>[undef,"ca","The string (or reference to an array of strings) to translate"],
             tit =>["Generated with 'uie'","c","Title to give to the generate page."],
             b8c =>[1    ,"n","Indicates if beginning and closing tags of the page",
                              "must be included."],
             pse =>["<>" ,"c","Lines starting with it start a new paragraph:",
                              "close the previous tag and open a new paragraph.",
                              "Also when a paragraph comprises an empty line,",
                              "it is interpreted as the start of a new paragraph.",
                              "Also the default value when no tag is a new paragraph."],
             lig =>["<->","c","Lines starting with it start a new paragraph after",
                              "introduction of an horizontal rule"],
             hdo =>[  "<","c","Opening of headings."],
             hdc =>[  ">","c","Closing of headings",
                              "(with defaults lines starting with '<#>'",
                              " are interpreted as heading # only when",
                              " # belongs to 1..6!)."],
             bul =>["<o>","c","Lines starting with it are item lines"],
             nul =>["<#>","c","Lines starting with it are numbered lines"]
            };
</pre></p>
<h2>
<a name="sub trace8script {"></a>
47 sub trace8script {
</h2>
<p><pre>
    #
    # title : displays some info at the start/end of a script
    #         
    #
    # aim: allow the tracking when using script launching scripts.
    #
    #
    # output: 1 when the display was done or an error message 
    #           when something is wrong.
    #
    # remark: don't forget that the use of 'getopts' empties the
    #         array @ARGV so you must save it in an auxillary
    #         array for proper call of this subroutine as soon as
    #         arguments must be displayed
    #
    # arguments
    my $hrsub = {cal  =>[undef,"a","script name and its arguments [$0,@ARGV]"],
                 typ  =>[undef,"c","'s' for start, 'e' for good end,",
                                   "'r' for error, else a message to be displayed in verbose case"],         
                 sty  =>[  102,"n","the value is 100*i+a where 'a' is giving the amount of information",
                                   "to display and 'i' guides the indentation",
                                   " 'a' can be 0: silent, 1:just the name, 2: plus arguments",
                                   "            3: plus time, > plus possible messages",
                                   " 'i' is the number of tabulation to introduce"]
                };
</pre></p>
<h2>
<a name="sub write8csv {"></a>
48 sub write8csv {
</h2>
<p><pre>
    #
    # title : writing a CSV file
    #
    # aim: write a csv file from an hash.
    #            Its keys will be the names of the csv columns,
    #            Associated values must be references to arrays
    #            having the same number of components: the values
    #            for the csv table to write into a file
    #
    # output: 1 if everything was fine and error which can be 
    #           filtred with &check8err.
    #
# arguments
my $hrsub = {str  =>[undef,"h","hash to be written as a CSV file"],
             csv  =>[undef,"c","Name of the CSV file to write"],
             sep  =>[  ";","c","Separator between fields within each line."]
            };
</pre></p>
<h2>
<a name="sub write8structure {"></a>
49 sub write8structure {
</h2>
<p><pre>
    #
    # title : write a structure in a file for future use
    #
    # aim : similar to &print8structure but to produce a
    #        piece of code, reusable with &read8structure.
    #
    # remarks: - references to scalar are transformed to scalars.
    #          - numerical values are transformed to character strings.
    #
    # output:  the cumulated string when everything was right. 
    #          If the file exists and must not a fatal error is raised.
    #
# arguments
my $hrsub = {str =>[undef,"csahu","The structure to be written"],
             fil =>[   "","c","Name of the file to be created",
                              "when '' a display on the screen"],
             cfi =>[    0,"n","Must the non existence of the file",
                              "be checked? If not a pre-existing",
                              "file will be replaced."],
             prm =>[20,"n","The maximum depth admitted for recursivity"],
             pro =>[0,"n","The depth of the display (used for recursivity)."],
             res =>["","c","String for recursive accumulation."]
            };
</pre></p>
<h2>
A total of 45 test scripts was detected:
</h2>
<p><pre>
</pre></p>
<ol>
<li>
<a href="uie_argu.pl">
uie_argu.pl
</a>
</li>
<li>
<a href="uie_ask8question.pl">
uie_ask8question.pl
</a>
</li>
<li>
<a href="uie_belong9.pl">
uie_belong9.pl
</a>
</li>
<li>
<a href="uie_check8array.pl">
uie_check8array.pl
</a>
</li>
<li>
<a href="uie_check8narray.pl">
uie_check8narray.pl
</a>
</li>
<li>
<a href="uie_check8ref.pl">
uie_check8ref.pl
</a>
</li>
<li>
<a href="uie_clean8string.pl">
uie_clean8string.pl
</a>
</li>
<li>
<a href="uie_compare8set.pl">
uie_compare8set.pl
</a>
</li>
<li>
<a href="uie_copy8structure.pl">
uie_copy8structure.pl
</a>
</li>
<li>
<a href="uie_dim4csv.pl">
uie_dim4csv.pl
</a>
</li>
<li>
<a href="uie_errors.pl">
uie_errors.pl
</a>
</li>
<li>
<a href="uie_extract8format.pl">
uie_extract8format.pl
</a>
</li>
<li>
<a href="uie_extract8name.pl">
uie_extract8name.pl
</a>
</li>
<li>
<a href="uie_extract8string.pl">
uie_extract8string.pl
</a>
</li>
<li>
<a href="uie_file9.pl">
uie_file9.pl
</a>
</li>
<li>
<a href="uie_get8answer.pl">
uie_get8answer.pl
</a>
</li>
<li>
<a href="uie_join8file.pl">
uie_join8file.pl
</a>
</li>
<li>
<a href="uie_join8hash.pl">
uie_join8hash.pl
</a>
</li>
<li>
<a href="uie_juste.pl">
uie_juste.pl
</a>
</li>
<li>
<a href="uie_justn.pl">
uie_justn.pl
</a>
</li>
<li>
<a href="uie_line4csv.pl">
uie_line4csv.pl
</a>
</li>
<li>
<a href="uie_make8eml.pl">
uie_make8eml.pl
</a>
</li>
<li>
<a href="uie_make8name.pl">
uie_make8name.pl
</a>
</li>
<li>
<a href="uie_name8file.pl">
uie_name8file.pl
</a>
</li>
<li>
<a href="uie_now.pl">
uie_now.pl
</a>
</li>
<li>
<a href="uie_numerical.pl">
uie_numerical.pl
</a>
</li>
<li>
<a href="uie_ordre.pl">
uie_ordre.pl
</a>
</li>
<li>
<a href="uie_pause.pl">
uie_pause.pl
</a>
</li>
<li>
<a href="uie_print8hmat.pl">
uie_print8hmat.pl
</a>
</li>
<li>
<a href="uie_print8panneau.pl">
uie_print8panneau.pl
</a>
</li>
<li>
<a href="uie_print8structure.pl">
uie_print8structure.pl
</a>
</li>
<li>
<a href="uie_read8block.pl">
uie_read8block.pl
</a>
</li>
<li>
<a href="uie_read8csv.pl">
uie_read8csv.pl
</a>
</li>
<li>
<a href="uie_read8line.pl">
uie_read8line.pl
</a>
</li>
<li>
<a href="uie_read8structure.pl">
uie_read8structure.pl
</a>
</li>
<li>
<a href="uie_replace8string.pl">
uie_replace8string.pl
</a>
</li>
<li>
<a href="uie_retrouve.pl">
uie_retrouve.pl
</a>
</li>
<li>
<a href="uie_save8file.pl">
uie_save8file.pl
</a>
</li>
<li>
<a href="uie_seqn.pl">
uie_seqn.pl
</a>
</li>
<li>
<a href="uie_spec2html.pl">
uie_spec2html.pl
</a>
</li>
<li>
<a href="uie_split8string.pl">
uie_split8string.pl
</a>
</li>
<li>
<a href="uie_text2html.pl">
uie_text2html.pl
</a>
</li>
<li>
<a href="uie_trace8script.pl">
uie_trace8script.pl
</a>
</li>
<li>
<a href="uie_write8csv.pl">
uie_write8csv.pl
</a>
</li>
<li>
<a href="uie_write8structure.pl">
uie_write8structure.pl
</a>
</li>
</ol>
</body>
</html>
